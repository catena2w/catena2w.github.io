# Transaction malleability in cryptocurrencies

In this article I'm going to provide brief review of protections against replay attacks, arising from signature malleability of elliptic curve cryptography.

## Problem

Most of cryptocurrencies are based on public-key cryptography.
Each owner transfers coins to the next one by digitally signing the transaction `Tx` containing the public key of the next owner.
So everyone can verify that sender wants to send this coins to the recipient, but the problem arises - how to predict to include `Tx` in the blockchain twice?
Without such a protection light-fingered recipient may repeat `Tx` until sender have enough coins on his balance, making impossible to reuse the same address for more then 1 transaction.
In particular the adversary can withdraw some coins from exchange and repeat this transaction until there are no coins left on exchange (such attacks where already used in practice, e.g. for [MtGox](https://arxiv.org/abs/1403.6676) attack).
The simplest way to keep all the included transactions and compare the new one to them don't work because of elliplic curve signature malleability - it is possible to change signature and remain it valid (see [here](http://crypto.stackexchange.com/a/14719)).
Scala code that changes signature in such a way is very simple:

```
    def forgeSignature25519(signature: Array[Byte]): Array[Byte] = {  
        val modificator: BigInt = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989")  
        signature.take(32) ++ (BigInt(signature.takeRight(32).reverse) + modificator).toByteArray.reverse  
    }
```

Thus, now we have sequence of transactions `Tx1`, ..., `TxN` with the same fields, but different signatures, and the challenge is to determine, whether they are all generated be sender or some of them are generated by the adversary. 

## Solutions

In this section I'll provide examples, how this problem is sold in different cryptocurrencies and will try to provide benefits and drawbacks of every approach.

### Canonical signature ([Factom](https://www.factom.com/), [Ripple](https://wiki.ripple.com/Transaction_Malleability), [Nxt](https://nxt.org/))
As far as there are sequence of valid signature, there may be a rule to select only one of them.
The usual way is to select *canonical signature*, which is lower then group generator ("7237005577332262213973186563042994240857116359379907606001950938285454250989" for curve25519).
Unfortunately some elliplic curves for any given canonical signature, an alternative form of that signature can be formed that is also canonical.
In such a case it's required to define *fully canonical signature*, which is the minimum from all equivalent signatures.
The main drawback for this approach is that *fully canonical signature* is not specified in protocol and default elliplic curve implementations don't usually check, whether signature is *canonical* and don't generate *canonical signature*, which makes cross-platform implementation much harder.

### Signature independent id (???)
It's also possible to modify transaction uniqueness check, leaving all possible signatures valid as specified in elliptic curve protocol.
For example it's possible to use the rule, that transaction data **excluding** signature should be valid.
This leads to drawback that you can't create 2 transactions with the same fields if you really want, while non-deterministic signatures may indicate, that sender really wanted to send 2 transaction with the same fields.
To fix this it's possible to include transaction id into transaction explicitly, e.g. some currencies sign transaction, use this signature as id and then sign this *internal* transaction with signature one more time.

### Nonce ([Ethereum](https://www.ethereum.org/), [Waves](http://wavesplatform.com/))
Another way is to add additional field to transactions, that should be increasing for transactions from the same address.
Current nonce for every account should be kept in state and on new transaction `Tx` nodes verify, that `Tx.nonce = account.nonce + 1`.
Besides of replay attack protection, nonce allows you to broadcast sequence of transactions and be sure, that only one of them will be included to blockchain.
For example, if you need you transaction to be included in block as soon as possible, you may rebroadcast your transaction with the same nonce, but increased fee and be sure, that only one of your transactions will pass all checks.
Nonce provides additional benefits for transactional layer, but not for free - every transaction should contain nonce, so transaction size become bigger.
On the other size nonce should be big enough, because it's not clear how to handle situation, when nonce limit is reached.
To fix this it's possible to try to reuse transaction field as nonce, for example use timestamp as nonce.
In such an approach it's not possible to require to increase nonce by 1, so rule `Tx.timestamp > account.timestamp` should be used.
This leads to another attack: if someone broadcasted sequence of transactions `Tx1`, ..., `TxN` with increasing timestamp, "evil" miner may only include `TxN` making transactions `Tx1`, ..., `TxN-1` invalid.

## Conclusion

It's not still clear for me, what's the best way to protect against replay attacks, arising from signature malleability of elliptic curves - each approach have it's benefits and drawbacks.
This approaches may be combined with each other, e.g. it's possible to require *canonical* signature together with nonce.
Feel free to provide more approaches and examples in comments, it would be cool choose an optimal solution!


